<!DOCTYPE html>
<html lang="en" class="no-js">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Master advanced debugging techniques in Flutter. Learn debugging tools, methods, and best practices for troubleshooting Flutter applications efficiently." />
  <title>Advanced Debugging Techniques in Flutter | DashStack Blog</title>
  <link rel="icon" href="./images/favicon.png" type="image/png" />
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Abyssinica+SIL&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Roboto+Slab:wght@100..900&display=swap"
    rel="stylesheet" />
  <!-- Custom CSS -->
  <link rel="stylesheet" href="./css/style.css" />
</head>

<body data-bs-spy="scroll">
  <!-- Enhanced Navigation -->
  <nav class="navbar navbar-expand-lg" id="mainNavbar">
    <div class="container">
      <a class="navbar-brand" href="/" aria-label="Flutter Development Company – DashStack">DASHSTACK</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ms-auto me-4">
          <li class="nav-item">
            <a class="nav-link" href="index.html#about">About</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="index.html#portfolio">Portfolio</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="index.html#services">Service</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="index.html#testimonial">Testimonial</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="blog.html">Blog</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="contact.html">Contact</a>
          </li>
        </ul>
        <button type="button" class="btn btn-consultation w-auto" data-bs-toggle="modal"
          data-bs-target="#staticBackdrop">
          Free Consultation
          <img src="./images/black_arrow.svg" alt="Arrow Right" />
        </button>
      </div>
    </div>
  </nav>

  <main>
    <!-- Blog Post Header -->
    <section class="blog-post-header-section">
      <div class="container">
        <div class="row justify-content-center">
          <div class="col-lg-8">
            <div class="blog-post-header-content">
              <div class="blog-breadcrumb mb-4">
                <a href="blog.html">Blog</a>
                <span class="mx-2">/</span>
                <span>Advanced Debugging Techniques in Flutter</span>
              </div>
              <div class="blog-category-tag mb-4">
                <span class="category-badge">Tips & Tricks</span>
              </div>
              <h1 class="blog-post-title mb-4">Advanced Debugging Techniques in Flutter</h1>
              <p class="blog-post-subtitle">Master comprehensive debugging strategies to identify and fix issues in Flutter applications. Learn professional tools and techniques used by experienced developers.</p>
              <div class="blog-post-meta mt-5 d-flex justify-content-between align-items-center">
                <div class="blog-post-author d-flex align-items-center">
                  <img src="./images/director_1.png" alt="Author" class="author-avatar me-3" />
                  <div>
                    <strong class="d-block">DashStack Engineering Team</strong>
                    <small class="text-muted">Flutter Development Experts</small>
                  </div>
                </div>
                <div class="blog-post-info">
                  <span class="me-4"><i class="fas fa-calendar-alt me-2"></i>Feb 3, 2026</span>
                  <span><i class="fas fa-clock me-2"></i>12 min read</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Blog Post Content -->
    <section class="blog-post-section">
      <div class="container">
        <div class="row justify-content-center">
          <div class="col-lg-8">
            <article class="blog-post-content">
              <p>
                Debugging is an essential skill for every Flutter developer. While basic debugging involves adding print statements and using breakpoints, professional Flutter developers leverage advanced techniques and tools to identify and resolve issues efficiently. In this comprehensive guide, we'll explore the arsenal of debugging tools and methodologies that separate experienced developers from novices.
              </p>

              <h2>Understanding Flutter's Debugging Architecture</h2>
              <p>
                Before diving into advanced techniques, it's important to understand how Flutter's debugging system works. Flutter applications run in the Dart Virtual Machine (VM), which provides rich debugging capabilities through the Dart Debug Protocol (DDP). The Dart SDK communicates with your IDE through this protocol to deliver real-time debugging information.
              </p>
              <p>
                Unlike traditional mobile debugging where you're limited to native platform tools, Flutter gives you access to both Dart-level debugging and platform channel debugging for native code. This dual debugging capability is powerful but requires understanding both layers.
              </p>

              <h2>1. Mastering the Dart DevTools Suite</h2>
              <p>
                The Dart DevTools is the most comprehensive debugging suite available for Flutter developers. It provides multiple specialized panels for different debugging scenarios.
              </p>

              <h3>The Debugger Panel</h3>
              <p>
                The Debugger panel is your window into the Dart execution stack. Beyond simple breakpoints, you can:
              </p>
              <ul>
                <li><strong>Set conditional breakpoints:</strong> Right-click a line and add conditions like `itemCount > 100` to pause execution only when specific conditions are met. This is invaluable for debugging issues that only occur under specific data conditions.</li>
                <li><strong>Use logpoints:</strong> Instead of pausing execution, logpoints let you print values to the console when a breakpoint is hit. This non-invasive approach helps you gather information without interrupting app flow.</li>
                <li><strong>Inspect variables:</strong> Hover over variables in the debugger to see their current state. For complex objects, expand the variable tree to inspect nested properties.</li>
                <li><strong>Watch expressions:</strong> Add custom expressions to the watch list that evaluate in real-time as you step through code. This helps you monitor derived values and conditions.</li>
                <li><strong>Evaluate expressions:</strong> Use the console within the debugger to execute Dart code and inspect objects dynamically without modifying your source code.</li>
              </ul>

              <h3>The Inspector Panel</h3>
              <p>
                The Inspector panel is your widget debugging tool. It visualizes your widget tree and allows you to:
              </p>
              <ul>
                <li>Select widgets directly from your running app to inspect their properties</li>
                <li>View the complete widget hierarchy and parent-child relationships</li>
                <li>Inspect layout information including size constraints, render object properties, and paint boundaries</li>
                <li>Use the "Show Paint Baselines" option to visualize text baselines and alignment</li>
                <li>Enable "Show Repaint Rainbow" to identify which widgets are rebuilding unnecessarily</li>
              </ul>

              <h3>The Performance Panel</h3>
              <p>
                This panel records and visualizes the frame rendering timeline. Use it to:
              </p>
              <ul>
                <li>Identify frames that exceed 16.67ms (60fps threshold) or 8.33ms (120fps)</li>
                <li>See which widgets consume the most render time</li>
                <li>Detect janky animations and identify root causes</li>
                <li>Track GPU and CPU thread performance separately</li>
              </ul>

              <h3>The Memory Panel</h3>
              <p>
                Memory leaks and excessive memory usage can crash applications. The Memory panel lets you:
              </p>
              <ul>
                <li>Take heap snapshots to analyze memory usage at specific points</li>
                <li>Compare snapshots over time to identify memory leaks</li>
                <li>See which objects consume the most memory</li>
                <li>Force garbage collection and monitor memory recovery</li>
              </ul>

              <h3>The Network Panel</h3>
              <p>
                For apps making HTTP requests, the Network panel is invaluable. It shows:
              </p>
              <ul>
                <li>All network requests with timing information</li>
                <li>Request and response headers</li>
                <li>Response body data (formatted for JSON)</li>
                <li>Network latency and total time per request</li>
              </ul>

              <h2>2. Console and Logging Strategies</h2>
              <p>
                While print statements seem simple, sophisticated logging strategies can dramatically improve debugging efficiency.
              </p>

              <h3>Structured Logging</h3>
              <p>
                Instead of ad-hoc print statements, implement structured logging:
              </p>
              <pre>import 'package:logging/logging.dart';

final logger = Logger('MyApp.SomeClass');

void initializeLogging() {
  Logger.root.level = Level.ALL;
  Logger.root.onRecord.listen((record) {
    print('${record.level.name}: ${record.time}: ${record.message}');
    if (record.error != null) {
      print('Error: ${record.error}');
      print('Stack trace: ${record.stackTrace}');
    }
  });
}

// Usage
logger.fine('Fetching user data');
logger.warning('Unexpected data format received');
logger.severe('Failed to save user data', error, stackTrace);</code></pre>

              <p>
                The `logging` package provides log levels (fine, info, warning, severe), timestamps, and structured output that's far superior to random print statements.
              </p>

              <h3>Conditional Logging</h3>
              <p>
                Use conditional compilation to enable detailed logging during development but disable it in production:
              </p>
              <pre> const bool kDebugMode = bool.fromEnvironment('DEBUG_MODE');

void debugLog(String message) {
  if (kDebugMode) {
    print('[DEBUG] $message');
  }
}</pre>

              <h2>3. Platform Channel Debugging</h2>
              <p>
                When your Flutter app communicates with native code via platform channels, debugging becomes more complex. You need to debug both sides:
              </p>

              <h3>Flutter Side</h3>
              <p>
                Use try-catch blocks to capture exceptions from platform channels:
              </p>
              <pre> try {
  final result = await platform.invokeMethod('getBatteryLevel');
} on PlatformException catch (e) {
  print("Failed: '${e.code}': ${e.message}");
} catch (e) {
  print("Unexpected error: $e");
}</pre>

              <h3>Native Side (iOS)</h3>
              <p>
                Use Xcode's debugger to inspect native Swift/Objective-C code:
              </p>
              <pre>// In Xcode: Product > Scheme > Edit Scheme > Run > Diagnostics
// Enable "OS Log" and "Console" to see native debug output

os_log("Battery level retrieved: %@", getBatteryLevel() as CVarArg)</pre>

              <h3>Native Side (Android)</h3>
              <p>
                Use Android Studio's debugger and logcat for native debugging:
              </p>
              <pre>import android.util.Log

const val TAG = "FlutterChannel"

Log.d(TAG, "Battery level: $batteryLevel")
Log.e(TAG, "Error retrieving battery level", exception)</pre>

              <h2>4. Advanced Debugging with Observatory</h2>
              <p>
                Observatory is Dart's native debugger that runs on a local server. While DevTools provides a web interface over Observatory, understanding Observatory directly is valuable:
              </p>
              <ul>
                <li>Run `flutter run --observatory-port=8889` to start your app with Observatory on port 8889</li>
                <li>Access Observatory at `http://localhost:8889` in your browser</li>
                <li>View loaded libraries and their source code</li>
                <li>Inspect VM-level information including isolates and service extensions</li>
              </ul>

              <h2>5. Widget Rebuild Optimization Debugging</h2>
              <p>
                Unnecessary rebuilds harm performance. Use these techniques to identify and eliminate them:
              </p>

              <h3>The Repaint Rainbow</h3>
              <p>
                Enable it in DevTools Inspector → Rendering → Show Repaint Rainbow. Widgets that repaint will flash with different colors. Excessive repainting indicates optimization opportunities.
              </p>

              <h3>Custom Performance Monitoring</h3>
              <pre>class DebugWidget extends StatelessWidget {
  final Widget child;
  final String name;

  const DebugWidget({
    required this.child,
    required this.name,
  });

  @override
  Widget build(BuildContext context) {
    print('[$name] rebuilding');
    return child;
  }
}</pre>

              <h3>Using shouldRebuild in ChangeNotifier</h3>
              <p>
                Instead of rebuilding the entire widget tree, use ChangeNotifierBuilder with targeted selectors:
              </p>
              <pre>Consumer<MyProvider>(
  selector: (context, provider) => provider.specificProperty,
  builder: (context, property, child) {
    print('Only rebuilding when specificProperty changes');
    return Text(property);
  },
)</code></pre>

              <h2>6. Error and Exception Handling Debugging</h2>
              <p>
                Comprehensive error handling is essential for production apps. Debug errors effectively with:
              </p>

              <h3>Custom Error Handlers</h3>
              <pre>void main() {
  // Catch Dart errors
  FlutterError.onError = (FlutterErrorDetails details) {
    FlutterError.presentError(details);
    // Send to error tracking service
    logErrorToService(details);
  };

  // Catch async errors
  PlatformDispatcher.instance.onError = (error, stack) {
    print('Uncaught async error: $error');
    print('Stack trace: $stack');
    return true;
  };

  runApp(MyApp());
}</pre>

              <h3>Error Context and Stack Traces</h3>
              <p>
                Always capture and analyze stack traces. The stack trace tells you exactly which functions called which, in what order:
              </p>
              <pre>try {
  riskyOperation();
} catch (e, stackTrace) {
  print('Error: $e');
  print('Stack trace:\n$stackTrace');
  
  // Parse stack trace to understand call sequence
  final frames = stackTrace.toString().split('\n');
  for (var frame in frames) {
    print('  $frame');
  }
}</pre>

              <h2>7. Hot Reload vs Hot Restart Debugging</h2>
              <p>
                Choosing between hot reload and hot restart is crucial for effective debugging:
              </p>
              <ul>
                <li><strong>Hot Reload:</strong> Preserves app state, updates code. Use when debugging UI or business logic. Won't work if you've modified declarations or constructors.</li>
                <li><strong>Hot Restart:</strong> Rebuilds entire app, clears state, applies all changes including package additions. Use when hot reload fails or you need to test initialization logic.</li>
              </ul>

              <h2>8. Async and Future Debugging</h2>
              <p>
                Asynchronous code is notoriously difficult to debug. Flutter provides specific techniques:
              </p>

              <h3>Future Debugging</h3>
              <pre>Future<String> fetchData() async {
  try {
    // Set breakpoint on the next line to pause at await
    final data = await api.getData();
    print('Data received: $data');
    return data;
  } catch (e) {
    print('Error: $e');
    rethrow; // Preserve stack trace
  }
}

// In DevTools: Debugger pauses at each await point</pre>

              <h3>Stream Debugging</h3>
              <pre>final counterStream = Stream.periodic(Duration(seconds: 1), (count) => count);

counterStream
  .doOnData((value) => print('Before mapping: $value'))
  .map((value) => value * 2)
  .doOnData((value) => print('After mapping: $value'))
  .listen((value) => print('Final: $value'));

// The 'do' operators let you observe stream values without modifying them</pre>

              <h2>9. State Management Debugging</h2>
              <p>
                Different state management solutions offer debugging capabilities:
              </p>

              <h3>Provider Debugging</h3>
              <pre>// Enable provider logging
void main() {
  FlutterError.onError = (error) {
    print('Provider error: $error');
  };
  runApp(MyApp());
}

// Use Consumer to track which providers rebuild
Consumer<MyProvider>(
  builder: (context, provider, child) {
    print('MyProvider rebuilt');
    return Text(provider.value);
  },
)</pre>

              <h3>GetX and Riverpod Debugging</h3>
              <p>
                GetX provides `Get.log()` for structured logging. Riverpod integrates with DevTools to show state changes in real-time.
              </p>

              <h2>10. Performance Profiling and Optimization</h2>
              <p>
                Beyond the Performance panel, use these techniques:
              </p>

              <h3>Frame Rate Monitoring</h3>
              <pre>import 'dart:developer' as developer;

void monitorFrameRate() {
  developer.Timeline.startSync('expensive_operation');
  
  // Your expensive operation here
  heavyCalculation();
  
  developer.Timeline.finishSync();
}</pre>

              <h3>Benchmark Testing</h3>
              <pre>import 'package:flutter_test/flutter_test.dart';

void main() {
  testWidgets('Benchmark list scroll', (WidgetTester tester) async {
    final sw = Stopwatch()..start();
    
    await tester.pumpWidget(MyListWidget());
    
    // Scroll and measure performance
    for (int i = 0; i < 100; i++) {
      await tester.drag(find.byType(ListView), Offset(0, -100));
      await tester.pumpAndSettle();
    }
    
    sw.stop();
    print('Scroll performance: ${sw.elapsedMilliseconds}ms');
  });
}</pre>

              <h2>11. Integration Testing as Debugging Tool</h2>
              <p>
                Integration tests can serve as debugging tools by automating the steps to reproduce issues:
              </p>
              <pre>testWidgets('Login flow', (WidgetTester tester) async {
  await tester.pumpWidget(MyApp());
  
  // Find and tap email field
  await tester.enterText(find.byType(TextField).first, 'user@example.com');
  
  // Tap login button
  await tester.tap(find.byType(ElevatedButton));
  
  // Wait for navigation
  await tester.pumpAndSettle();
  
  // Verify successful login
  expect(find.byType(HomePage), findsOneWidget);
});

// This test documents the expected flow and catches regressions</pre>

              <h2>12. Remote Debugging and Production Issues</h2>
              <p>
                Debugging issues that only occur in production requires specialized approaches:
              </p>
              <ul>
                <li><strong>Crash Reporting:</strong> Use Firebase Crashlytics or Sentry to capture crashes in production with full stack traces</li>
                <li><strong>Analytics:</strong> Track user behavior leading up to crashes</li>
                <li><strong>Remote Logging:</strong> Send logs to a server for analysis</li>
                <li><strong>Beta Testing:</strong> Release to beta testers first to catch issues before production</li>
              </ul>

              <h2>Debugging Best Practices Summary</h2>
              <ul>
                <li>Use structured logging instead of random print statements</li>
                <li>Leverage DevTools for comprehensive debugging across all aspects</li>
                <li>Set up proper error handling and exception catching from the start</li>
                <li>Monitor performance proactively rather than reactively</li>
                <li>Use conditional breakpoints and logpoints for non-invasive debugging</li>
                <li>Test thoroughly on physical devices, not just simulators</li>
                <li>Enable crash reporting in production to catch real-world issues</li>
                <li>Keep detailed logs to replay and understand issue sequences</li>
              </ul>

              <h2>Conclusion</h2>
              <p>
                Mastering advanced debugging techniques transforms you from a developer who guesses at problems to one who systematically identifies and resolves issues. The tools and techniques covered in this guide—from DevTools panels to platform channel debugging to production error monitoring—form a comprehensive debugging arsenal.
              </p>
              <p>
                Remember that debugging is not a punishment for bad code; it's a normal and essential part of development. The faster you can identify issues and understand their root causes, the more productive you become. Invest time in learning these tools and techniques thoroughly, and you'll find yourself solving problems with confidence and efficiency.
              </p>
              <p>
                At DashStack, we've debugged thousands of Flutter applications across different industries and platforms. Our experience has shown us that developers who master these debugging techniques deliver higher-quality applications with fewer issues in production. Start applying these advanced debugging techniques in your next project, and watch your development efficiency soar.
              </p>

              <!-- Share Section -->
              <div class="blog-post-share">
                <button class="share-btn" title="Share on Twitter"><i class="fab fa-twitter"></i></button>
                <button class="share-btn" title="Share on LinkedIn"><i class="fab fa-linkedin"></i></button>
                <button class="share-btn" title="Share on Facebook"><i class="fab fa-facebook"></i></button>
                <button class="share-btn" title="Copy link"><i class="fas fa-link"></i></button>
              </div>
            </article>
          </div>
        </div>
      </div>
    </section>

    <!-- Related Posts -->
    <section class="blog-related-section">
      <div class="container">
        <h2>Related Articles</h2>
        <div class="row">
          <div class="col-lg-4 col-md-6 mb-4">
            <article class="blog-card">
              <div class="blog-card-image">
                <img src="https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=500&h=300&fit=crop" alt="Flutter Best Practices" />
                <span class="blog-category-badge">Flutter</span>
              </div>
              <div class="blog-card-content">
                <h3 class="blog-card-title">
                  <a href="blog-post-flutter-best-practices.html">Flutter Best Practices for Production Apps</a>
                </h3>
                <p class="blog-card-excerpt">
                  Learn essential best practices when developing Flutter applications for production environments...
                </p>
                <div class="blog-card-meta">
                  <span class="blog-date"><i class="fas fa-calendar"></i> Feb 10, 2026</span>
                  <span class="blog-read-time"><i class="fas fa-clock"></i> 5 min read</span>
                </div>
                <a href="blog-post-flutter-best-practices.html" class="blog-read-more">
                  Read More <i class="fas fa-arrow-right"></i>
                </a>
              </div>
            </article>
          </div>
          <div class="col-lg-4 col-md-6 mb-4">
            <article class="blog-card">
              <div class="blog-card-image">
                <img src="./images/flutter_placeholder_1.jpg" alt="State Management" />
                <span class="blog-category-badge">Flutter</span>
              </div>
              <div class="blog-card-content">
                <h3 class="blog-card-title">
                  <a href="blog-post-state-management.html">Choosing the Right State Management in Flutter</a>
                </h3>
                <p class="blog-card-excerpt">
                  A comprehensive guide to different state management solutions available in Flutter...
                </p>
                <div class="blog-card-meta">
                  <span class="blog-date"><i class="fas fa-calendar"></i> Jan 30, 2026</span>
                  <span class="blog-read-time"><i class="fas fa-clock"></i> 10 min read</span>
                </div>
                <a href="blog-post-state-management.html" class="blog-read-more">
                  Read More <i class="fas fa-arrow-right"></i>
                </a>
              </div>
            </article>
          </div>
          <div class="col-lg-4 col-md-6 mb-4">
            <article class="blog-card">
              <div class="blog-card-image">
                <img src="https://images.unsplash.com/photo-1561070791-2526d30994b5?w=500&h=300&fit=crop" alt="Flutter Web Development" />
                <span class="blog-category-badge">Web Development</span>
              </div>
              <div class="blog-card-content">
                <h3 class="blog-card-title">
                  <a href="blog-post-flutter-web-development.html">Flutter for Web Application Development in 2026</a>
                </h3>
                <p class="blog-card-excerpt">
                  Discover how Flutter enables seamless cross-platform web development with a single codebase...
                </p>
                <div class="blog-card-meta">
                  <span class="blog-date"><i class="fas fa-calendar"></i> Feb 8, 2026</span>
                  <span class="blog-read-time"><i class="fas fa-clock"></i> 9 min read</span>
                </div>
                <a href="blog-post-flutter-web-development.html" class="blog-read-more">
                  Read More <i class="fas fa-arrow-right"></i>
                </a>
              </div>
            </article>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Enhanced Footer -->
  <footer class="footer">
    <div class="container">
      <div class="row g-4 d-none">
        <div class="col-lg-6 col-md-12">
          <h5>Subscribe newsletter</h5>
          <p class="mb-4">
            Subscribe our newsletter to get the latest news and updates!
          </p>
          <div class="footer-email">
            <img src="./images/email.svg" alt="Newsletter Icon" class="me-2" />
            <input type="email" class="form-control" placeholder="Enter your email address" id="emailInput" />
            <button class="btn btn-subscribe">Subscribe</button>
          </div>
        </div>
        <div class="col-lg-2 col-md-4">
          <h5 class="mb-4">Company</h5>
          <ul>
            <li><a href="#about">Who we are</a></li>
            <li><a href="#services">Our services</a></li>
            <li><a href="#clients">Our clients</a></li>
            <li><a href="#contact">Contact us</a></li>
          </ul>
        </div>
        <div class="col-lg-2 col-md-4">
          <h5 class="mb-4">Services</h5>
          <ul>
            <li><a href="#">Planning</a></li>
            <li><a href="#">Research</a></li>
            <li><a href="#">Consulting</a></li>
            <li><a href="#">Analysis</a></li>
          </ul>
        </div>
        <div class="col-lg-2 col-md-4">
          <img src="./images/footer_img.png" alt="Footer Logo" class="mb-3 img-fluid" />
        </div>
      </div>
      <div class="d-flex align-items-center quote-section">
        <div class="d-flex align-items-center text-left mb-4 mb-sm-4 mb-lg-0">
          <img src="./images/logo.svg" alt="DashStack FooterLogo" class="footer-logo me-4" />
          <p class="mb-0">
            Powering Digital Journeys from<br />
            Startups to Enterprises.
          </p>
        </div>
        <div class="d-flex title-content flex-wrap">
          <div>
            <span>Drop Us An Email</span>
            <a class="d-block" href="mailto:team@dashstack.tech">
              team@dashstack.tech
            </a>
          </div>
          <div>
            <span>Call Our Project Experts</span>
            <a class="d-block" href="tel:+918153916802">(+91) 8153 9168 02</a>
          </div>
        </div>
      </div>
      <div class="footer-bottom d-flex flex-column flex-md-row justify-content-between align-items-center">
        <p aria-label="Mobile App Development Company">© 2026 DashStack Infotech – Flutter App Development Company. All
          rights reserved.</p>
        <div class="social-icons">
          <a class="me-2" href="https://in.linkedin.com/company/dashstack-infotech">
            <img src="./images/linkedin_icon.png" alt="LinkeDin" />
          </a>
          <a class="me-2" href="https://pub.dev/publishers/dashstack.tech/packages">
            <img src="./images/flutter_icon.png" alt="Flutter Open-Source Packages" />
          </a>
          <a class="me-2" href="https://share.google/jNeEXJylERyU6zyFs">
            <img src="./images/google_icon.png" alt="Google" />
          </a>
          <a href="https://www.instagram.com/flutter_dev_ravi/">
            <img src="./images/instagram_icon.png" alt="Instagram" />
          </a>
        </div>
      </div>
    </div>
  </footer>

  <!-- Enhanced Footer -->
  <!-- Footer -->

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>
